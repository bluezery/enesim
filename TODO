Enesim
======
+ Make the simple renderer work
+ Make every renderer that now inherits from enesim renderer depend on enesim renderer simple
+ Make every shape renderer use the shape simple, we need to figure out what to do with
  stroke location givne that the path does not support it.
+ Add a multi path backend renderer. Given that we make every shape renderer use the simple
  shape renderer. We can define a multi backend renderer (where backend can be agg, cairo,
  enesim, skia, whatever) to render a path with all the shape properties.
+ We have a performance problem when some renderer has changed. Basically on the practice
  we end having a full tree of renderers, several levels, proxies, whatever. When we need
  to know what area to draw we basically iterate over all the tree. That means that we start
  from the topmost renderer and then going down, even if no children has actually changed
  we still need to call a function on each child to see if it has changed or not. In case
  of damages it is the same.

  So we need a way to inform somehow whenever a renderer has changed "upstream" to avoid
  iterating over all the children Here upstream refers that if a renderer is for example
  added on a compound renderer, when the children have a _set() function it should call a
  function in the form of:
  enesim_renderer_notify_change().
  This function should call a list of "listeners" of such
  "event" so for example the compund renderer can listen to that and again inform "upstream"
  of a change.
+ Add log levels on every subsystem/renderer
+ We should add a way to get the backend data from a renderer or surface. This is useful for
  cases like the glx example where we need a way to render the texture inside a surface into
  the final framebuffer. Another useful case might be on the future for a new way to define
  renderers or extend them. Instead of calling the enesim_renderer_setup() as is, we might
  want to get the backend data and manage that data directly
+ Add a pattern renderer. Basically it should just draw another renderer inifinitely, of course
 if we want to restrict it to a specific area, then we should use a clipper? or maybe make the
 pattern clip also?
+ Make use of the flags on the surface draw function
+ We need to optimize and avoid the need to always call
  enesim_renderer_data_get(r) whenever we want to render a span, for such, extend such function
  to receive the data already fetch with enesim_renderer_data_get(r) but on the surface_draw
+ Change very renderer to use *thiz* as the variable for itself
+ We need to get rid of the hypot function, it is used on a lot places
  but with f16p16 values
+ We need to use the real types on the rendering functions
+ We need to simplify the real rendering functions into its own
  c file with its own struct, this way in the future we can reuse the
  algorithm for other backends
+ Split the hswitch and transition common parts into a common transition renderer
  with properties as src, target and step, that's all
+ This one is important, is time to worry about the memory, given that renderers can go inside others
  and so forth, why not instead of doing enesim_delete we do enesim_ref/unref, this might do our lifes
  easier
  already done:
  other/compound
  other/clipper
  shape/shape
  transition/transition
+ Normalize the stride/pitch
+ Initialize every renderer to some sane vales
+ We need to use whenever possible functions for fixed point operations. This way later we can just
  create some #defines for them and we can easily change from 16.16 to 32.32 or stuff like that
+ The renderers should implement or even the change interface or the damage, there's no need to iterate
  the rendernig tree twice, one for the change callback and another for the damage callback
+ If we do the above then we should remove the enesim_renderer_has_changed API function, it should just
  request the damages. If no damages, then no change, etc. Or implement the changed as a call to damages
  with a simple callback that whenever a some damage area is returned then we should just abort and return
  true

Etex
====
+ Add fontconfig support
+ Add a path-follow-span, i.e a text span that can receive
  a shape and use that as the path to follow. We need more
  code on enesim to know whenever a renderer is of a specific
  type, similar to what we are doing on eon
+ Add rich text element

